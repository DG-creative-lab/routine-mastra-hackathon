// src/template-builder/scaffolders.ts
import type { RoutinePlan, ToolBinding } from "./types";

export function file_planJson(planRaw: string) {
  return planRaw; // write verbatim
}

export function file_nodesTs(plan: RoutinePlan) {
  return `// AUTO-GENERATED — nodes.ts
// Represents each Routine step as a node descriptor.
// You can replace this with Mastra's createStep later.

export type Node = {
  id: string;
  tool: string;
  inputs: Record<string, any>;
  condition?: string;
  outputs?: string[];
};

export const nodes: Node[] = ${JSON.stringify(
    plan.map(s => ({
      id: `step-${s.id}`,
      tool: s.tool,
      inputs: s.inputs ?? {},
      condition: s.condition ?? "",
      outputs: s.outputs ?? [],
    })),
    null,
    2
  )};
`;
}

export function file_workflowTs(plan: RoutinePlan, toolBindings: ToolBinding[]) {
  const uniqueImports = Array.from(
    new Map(toolBindings.map(b => [b.importName, b])).values()
  );

  // helper to render per-step call
  const stepCalls = plan.map((s) => {
    const binding = toolBindings.find(b => b.id === s.tool);
    const inputsExpr = JSON.stringify(s.inputs ?? {}, null, 0);

    const call = binding
      ? binding.invoke(`resolveInputs(${inputsExpr}, ctx)`)
      : `/* TODO: implement tool '${s.tool}' */ null`;

    const cond = s.condition
      ? `if (evaluateCondition(${JSON.stringify(s.condition)}, ctx)) {\n      result = ${call};\n    } else { result = null; }`
      : `result = ${call};`;

    const saveOutputs = (s.outputs?.length ?? 0) > 0
      ? s.outputs!.map((name, idx) => `ctx["$${s.id}.${name}"] = (result && result.${name} !== undefined) ? result.${name} : Array.isArray(result) ? result[${idx}] : result;`).join("\n    ")
      : `ctx["$${s.id}.result"] = result;`;

    return `
  // Step ${s.id} — ${s.tool}${s.description ? ` — ${s.description}` : ""}
  {
    let result: any = null;
    ${cond}
    ${saveOutputs}
  }`.trim();
  }).join("\n");

  return `// AUTO-GENERATED — workflow.ts
// Minimal runtime that executes the Routine plan by calling bound tools.
// This is framework-agnostic; swap to Mastra's createWorkflow later.

import {
${uniqueImports.map(b => `  ${b.importName},`).join("\n")}
} from "${uniqueImports[0]?.importPath ?? "../../src/tools"}";

type Ctx = Record<string, any>;

function get(ctx: Ctx, ref: string) {
  // ref like "$2.flag" or "$1.result"
  return ctx[ref];
}

function resolveInputs(obj: any, ctx: Ctx): any {
  if (obj == null || typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map(v => resolveInputs(v, ctx));
  const out: any = {};
  for (const [k, v] of Object.entries(obj)) {
    if (typeof v === "string" && v.startsWith("$")) {
      out[k] = get(ctx, v);
    } else {
      out[k] = resolveInputs(v, ctx);
    }
  }
  return out;
}

// WARNING: toy evaluator — supports ==, !=, >, < and reading $-refs.
function evaluateCondition(expr: string, ctx: Ctx): boolean {
  try {
    const safe = expr.replace(/\\$\\d+\\.[A-Za-z0-9_]+/g, (m) => {
      const val = JSON.stringify(get(ctx, m));
      return val ?? "null";
    });
    // eslint-disable-next-line no-new-func
    return Boolean(Function(\`return (\${safe});\`)());
  } catch {
    return false;
  }
}

export async function run(initial: Record<string, any> = {}) {
  const ctx: Ctx = { ...initial };

${stepCalls}

  return ctx; // keep all intermediate values for debugging
}

export default { run };
`;
}

export function file_criticsTs() {
  return `// AUTO-GENERATED — critics.ts
// Add safety guards here & attach in your real workflow runner (Mastra).
export const critics = {
  // noBidChangeOver25Pct: (ctx:any) => {
  //   if (Math.abs(ctx.deltaPct) > 25) throw new Error("Bid change > 25%");
  // },
};
export default critics;
`;
}

export function file_registerTs() {
  return `// AUTO-GENERATED — register.ts
// Stub for future \`mastra deploy\`. Hook in your workflow + tools registration.
export async function register() {
  return true;
}
export default register;
`;
}

export function file_readmeMd(title = "Generated Template") {
  return `# ${title}

This template was generated by **Meta-Template Builder** from a Routine plan.

## Files

- \`plan.json\` — canonical plan
- \`nodes.ts\` — node descriptors
- \`workflow.ts\` — minimal runner (replace with Mastra createWorkflow later)
- \`critics.ts\` — guards (add yours)
- \`register.ts\` — stub for deploy

> Tip: open \`workflow.ts\` and wire into Mastra's steps if you want typed ports.
`;
}